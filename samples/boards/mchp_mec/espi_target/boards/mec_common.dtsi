/*
 * Copyright (c) 2024 Microchip Technology Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/gpio/gpio.h>
#include <zephyr/dt-bindings/gpio/microchip-xec-gpio.h>
#include <zephyr/dt-bindings/espi/mchp-mec5-espi.h>

/* Sample runs MEC_ASSY6941 board with MEC174x or MEC175x CPU card installed.
 * -------------------------------------------
 * MEC5_ASSY6941 EVB with MEC1743Q-LJ CPU card
 * EVB power !! Selected one !!
 * Selected: Jumper on J1 5-6 selects +5V 2.1mm ID 5.5mm OD barrel connector from
 *  an external +5V power brick.
 * Jumper on J1 1-2 uses +5VCC_IN from edge connector Z1
 * Jumper on J1 3-4 uses VVD_+5V from variable voltage header J2-21
 * Jumper on J1 7-8 uses MCP2200_VBUS from MCP2200 using USB connector P2
 * Jumper on J1 9-10 uses USBPWR_FT4222 USB connector J62
 *
 * Configure VTR2 as 1.8V rail
 * JP32 2-3 +1.8V_STBY from 1.8V regulator
 * JP45 1-2 connect +1.8V_STBY to J68-3
 * JP68 3-4 connect +1.8V_STBY to JP62-1 and Q switch Q16
 * JP62 1-2 connect +1.8V_STBY to VTR2 bypassing Q switch
 * JP65 1-2 connects VTR2 to VCHIP_VTR2
 * NOTE: VTR3 is always 1.8V
 *
 * Use +3.3V and +1.8V generated by EVB regulators
 * JP231 1-2, JP33 2-3, JP31 2-3, JP32 2-3
 *
 * VTR1 voltage select +3.3V_STBY
 * JP43 1-2, JP159 1-2, JP58 1-2, JP60 1-2
 *
 * VTR2 voltage select +1.8V_STBY
 * JP45 1-2, J68 3-4, JP62 1-2, JP65 1-2
 *
 * VTR3 voltage select +1.8V_STBY
 * JP45 1-2, JP160 1-2, JP66 1-2, JP68 1-2
 *
 * Straps:
 * UART_BSTRAP: JP1
 * CR_STRAP: JP2
 * JTAG_STRAP: JP3
 * CMP_STRAP: JP4
 * PWRGD_STRAP: JP5
 * VTR2_STRAP: JP6
 * BSS_STRAP: JP7
 * BSS_STRAP: JP8 2-3
 * CRISIS_RECOVERY_STRAP: JP9
 *
 * Enable EVB eSPI voltage translators
 * JP110 1-2 U10 OE connected to VTR3 (enabled)
 * JP116 1-2 U12 and U13 nOE connected to VTR3 (disabled)
 *
 * The board acting as eSPI emulated host must have its QSPI
 * SHD_xxx pins on +1.8V. QSPI SHD pins are all on the VTR2 rail.
 * Connect QSPI pins from emulated Host board to this board:
 * SHD_nCS1 ->  ESPI_nCS J46-1  <-> U10 <-> ESPI_nRESET_R J52-19, JP114-1
 * SHD_CLK  ->  ESPI_CLK J46-3  <-> U10 <-> ESPI_CLK_R    J52-13
 * SHD_IO0  <-> ESPI_IO0 J46-5  <-> U10 <-> ESPI_IO0_R    J52-7
 * SHD_IO1  <-> ESPI_IO0 J46-7  <-> U10 <-> ESPI_IO1_R    J52-5
 * SHD_IO2  <-> ESPI_IO0 J46-9  <-> U10 <-> ESPI_IO2_R    J52-3
 * SHD_IO3  <-> ESPI_IO0 J46-11 <-> U10 <-> ESPI_IO3_R    J52-1
 *
 * Emulated eSPI Host uses a GPIO as ESPI_nRESET to Target
 * H2T_ESPI_nRESET -> ESPI_nRESET J46-15
 *
 * Emulated eSPI Host uses a GPIO as ESPI_nALERT to Target
 * H2T_ESPI_nALERT -> ESPI_nALERT J46-13
 *
 * Synchronization signals:
 * H2T_VCC_PWRGD -> VCC_PWRGD_ALT GPIO242 Func 3
 *
 * T2H_nREADY <- GPIO031(VTR1) output active low. Init to high
 *		J41-7
 *		JP75 21-22 100K pull-up. Do not install
 *		Pull-up enabled on eSPI Host Emulation board
 *
 * GPIO175/CMP_VOUT1/PWM8_ALT on schematic, LED4 on silkscreen.
 * JP19 16-17 connects GPIO175 as CMP_VOUT1
 *
 * I2C00_SDA/SCL = GPIO003/004 selection
 * Install Jumpers on JP15 4-5, JP15 7-8, JP27 31-32, JP27 34-35
 * If pull-ups on the EVB are required:
 * Install Jumper JP70 19-20 7.5K pull-up to VTR1 for I2C00_SCL
 * Install Jumper JP70 21-22 7.5K pull-up to VTR1 for I2C00_SDA
 *
 * I2C devices on EXTERNAL_SDA/SCL bus
 *
 * U4 is PCA9555 I2C GPIO expander
 * JP52 1-2 use +3.3V_STBY
 * JP61 1-2, 3-4 connects I2C00_SCL and I2C00_SDA to EXTERNAL_SCLK/SDATA
 * JP55 selects I2C address
 * 1-2 = A0, 3-4 = A1, 5-6 = A2 all pulled-up by default. Install jumper to ground signals.
 * Installed jumper on JP53 1-2. I2C Address = 0x26
 *
 * U18 is LTC2489CDE I2C 4-channel delta-sigma ADC
 * NOTE: LTC2489 is powered by +5V.
 * Address select pins CA0, CA1 both pulled high. Install jumpers to ground signals.
 * Installed jumpers on JP121 1-2 and 3-4. I2C Address = 0x34
 * VRef=3V J51 1-2
 * Channel 0 connected to Vin=2.048V JP120 1-2, J51 3-4
 */

/ {
	chosen {
		espi,os-acpi = &acpi_ec0;
		espi,host-cmd-acpi = &acpi_ec1;
		espi,host-mailbox = &mbox0;
		espi,host-shm = &emi0;
		espi,host-em8042 = &kbc0;
		espi,host-uart = &uart0;
		espi,host-io-capture = &p80bd0;
	};

	aliases {
		spi0 = &qspi0;
		led0 = &led4;
		i2c0 = &i2c_smb_0;
		i2c-0 = &i2c_smb_0;
	};

	leds {
		compatible = "gpio-leds";
		led4: led_0 {
			gpios = <MCHP_GPIO_DECODE_175 GPIO_ACTIVE_HIGH>;
		};
	};

	/* zephyr,user is a special case node for application & test use
	 * This node does not require a YAML binding file.
	 * espi-gpio pins
	 * index 0 = Target nREADY output to Host eSPI emulator
	 * index 1 = VCC_PWRGD_ALT drivent by external eSPI Emulated Host board
	 * In application code use GPIO_DT_SPEC_GET_BY_IDX() macro.
	 */
	zephyr,user {
		espi-gpios = <MCHP_GPIO_DECODE_031 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_242 0>;
		pinctrl-0 = <&vcc_pwrgd_alt_gpio242 &pwrok_gpio106>;
		pinctrl-names = "default";
	};
};

&i2c00_scl_gpio004 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

&i2c00_sda_gpio003 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

/* ---- eSPI and peripheral channel devices ---- */

&espi0 {
	status = "okay";
	pinctrl-0 = < &espi_reset_n_gpio061
		      &espi_clk_gpio065 &espi_cs_n_gpio066
		      &espi_io0_gpio070 &espi_io1_gpio071
		      &espi_io2_gpio072 &espi_io3_gpio073 >;
	pinctrl-names = "default";
	host-memmap-addr-high = <0x10>; /* bits[47:32] of Host address for memory mapped LDNs */
	sram-bar-addr-high = <0x20>; /* bits[47:32] of Host address for SRAM BARs */

	/* We create a node here for the UART we will expose to the Host
	 * Doing this makes sure this node is a child of espi0 required
	 * by espi0's driver.
	 */
	uart0_host: uart0_host {
		compatible = "microchip,mec5-host-uart";
		pinctrl-0 = < &uart0_tx_gpio104 &uart0_rx_gpio105 >;
		pinctrl-names = "default";
		hwdev = <&uart0>;
		host-infos = <&espi_uart0>;
		status = "okay";
	};
};

/* Map UART0 to Host I/O address space */
&espi_uart0 {
	host-address = <0x3f8>;
	sirqs = <4>;
	status = "okay";
};

/* Enable eSPI SRAM BAR0 to map a 256 byte region of EC SRAM to Host
 * address space with read-only access.
 * ISSUE: region-base, shouldn't this be the address of an application buffer?
 */
&espi_sram_bar0 {
	host-address-lsw = <0x20000000>;
	region-base = <0x118000>;
	region-size = "256B";
	access = "READ_ONLY";
	status = "okay";
};

/* Enable eSPI SRAM BAR1 to map a 256 byte region of EC SRAM to Host
 * address space with write-only access.
 */
&espi_sram_bar1 {
	host-address-lsw = <0x20001000>;
	region-base = <0x118100>;
	region-size = "256B";
	access = "WRITE_ONLY";
	status = "okay";
};

/* eSPI Host OS ACPI_EC device */
&acpi_ec0 {
	compatible = "microchip,mec5-acpi-ec-os";
	host-infos = <&espi_acpi_ec0>;
	status = "okay";
};

&espi_acpi_ec0 {
	host-address = <0x62>;
	sirqs = <5>;
	sirq-names = "ec_obf";
	status = "okay";
};

/* eSPI Host command ACPI_EC device */
&acpi_ec1 {
	compatible = "microchip,mec5-acpi-ec-hcmd";
	host-infos = <&espi_acpi_ec1>;
	status = "okay";
};

&espi_acpi_ec1 {
	host-address = <0x200>;
	sirqs = <0xff>;
	sirq-names = "ec_obf";
	status = "okay";
};

/* Use eSPI Host KBC driver and map KBC0 and KB Port92h to Host I/O space */
&kbc0 {
	compatible = "microchip,mec5-kbc";
	host-infos = <&espi_kbc0 &espi_kb_port92>;
	status = "okay";
};

&espi_kbc0 {
	host-address = <0x60>;
	sirqs = <1 12>;
	sirq-names = "kirq", "mirq";
	status = "okay";
};

&espi_kb_port92 {
	host-address = <0x92>;
	status = "okay";
};

/* Use eSPI Mailbox driver and map mailbox to Host I/O space */
&mbox0 {
	compatible="microchip,mec5-mailbox";
	host-infos = <&espi_mbox0>;
	status = "okay";
};

&espi_mbox0 {
	host-address = <0x300>;
	sirqs = <0xff 0xff>;
	status = "okay";
};

/* Map EMI0 to Host memory address space. */
&emi0 {
	compatible = "microchip,mec5-shm-emi";
	host-infos = <&espi_emi0>;
	status = "okay";
};

&espi_emi0 {
	host-address = <0x10000000>;
	host-mem-space;
};

/* Map EMI1 to Host memory address space */
&emi1 {
	compatible = "microchip,mec5-shm-emi";
	host-infos = <&espi_emi1>;
	status = "okay";
};

&espi_emi1 {
	host-address = <0x10001000>;
	host-mem-space;
};

/* eSPI Host I/O capture device. Map 4-byte Host I/O capture range and
 * optional 1-byte I/O alias.
 */
&p80bd0 {
	compatible = "microchip,mec5-bdp";
	host-infos = <&espi_bdp0 &espi_bdpa0>;
	status = "okay";
};

&espi_bdp0 {
	host-address = <0x80>;
};

&espi_bdpa0 {
	host-address = <0x90>;
	bdp-host-alias-byte-lane = <1>;
};

&i2c_smb_0 {
	status = "okay";
	port_sel = < 0 >;
	sda-gpios = < MCHP_GPIO_DECODE_003 0 >;
	scl-gpios = < MCHP_GPIO_DECODE_004 0 >;
	pinctrl-0 = < &i2c00_sda_gpio003 &i2c00_scl_gpio004 >;
	pinctrl-names = "default";

	pca9555_evb: pca9555@26 {
		compatible = "nxp,pca9555";
		reg = <0x26>;
		gpio-controller;
		#gpio-cells = <2>;
	};

	ltc2489_evb: ltc2489@34 {
		/* No Zephyr driver exists */
		reg = <0x34>;
		#io-channels-cells = <1>;
	};
};
