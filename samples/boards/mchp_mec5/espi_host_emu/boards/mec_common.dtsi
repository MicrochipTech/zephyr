/*
 * Copyright (c) 2023 Microchip Technology Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/gpio/gpio.h>
#include <zephyr/dt-bindings/gpio/microchip-xec-gpio.h>
#include <zephyr/dt-bindings/espi/mchp-mec5-espi.h>

/* Sample for MEC_ASSY6941 board with various CPU cards.
 * -----------------------------------------------------
 * With MEC1743Q-LJ CPU card
 * EVB power !! Selected one !!
 * Selected: Jumper on J1 5-6 selects +5V 2.1mm ID 5.5mm OD barrel connector from
 *  an external +5V power brick.
 * Jumper on J1 1-2 uses +5VCC_IN from edge connector Z1
 * Jumper on J1 3-4 uses VVD_+5V from variable voltage header J2-21
 * Jumper on J1 7-8 uses MCP2200_VBUS from MCP2200 using USB connector P2
 * Jumper on J1 9-10 uses USBPWR_FT4222 USB connector J62
 *
 * Configure VTR2 as 1.8V rail
 * JP32 2-3 +1.8V_STBY from 1.8V regulator
 * JP45 1-2 connect +1.8V_STBY to J68-3
 * JP68 3-4 connect +1.8V_STBY to JP62-1 and Q switch Q16
 * JP62 1-2 connect +1.8V_STBY to VTR2 bypassing Q switch
 * JP65 1-2 connects VTR2 to VCHIP_VTR2
 * NOTE: VTR3 is always 1.8V
 *
 * Use +3.3V and +1.8V generated by EVB regulators
 * JP231 1-2, JP33 2-3, JP31 2-3, JP32 2-3
 *
 * VTR1 voltage select +3.3V_STBY
 * JP43 1-2, JP159 1-2, JP58 1-2, JP60 1-2
 *
 * VTR2 voltage select +1.8V_STBY
 * JP45 1-2, J68 3-4, JP62 1-2, JP65 1-2
 *
 * VTR3 voltage select +1.8V_STBY
 * JP45 1-2, JP160 1-2, JP66 1-2, JP68 1-2
 *
 * Straps:
 * UART_BSTRAP: JP1
 * CR_STRAP: JP2
 * JTAG_STRAP: JP3
 * CMP_STRAP: JP4
 * PWRGD_STRAP: JP5
 * VTR2_STRAP: JP6
 * BSS_STRAP: JP7
 * BSS_STRAP: JP8 2-3
 * CRISIS_RECOVERY_STRAP: JP9
 *
 * Boot-ROM GPIO055 as RSMRST#
 * GPIO Control register value = 0x0200
 * Output, push-pull, driver low, no internal pulls,
 * interrupt detection = level low, alternate out enabled.
 * ROM drives pin high(inactive) using alternate out (bit[16] of control register)
 * Control register = 0x10200
 *
 * Select GPIO057 as VCC_PWRGD input. JP17 19-20, JP19 8-9
 * Connect VCC_PWRGD to VTR1, switch S1, and U2(MCP121T-300). JP36 1-2
 * JP34 1-2 VTR1 powers VDD input of U2.
 * On CPU card assembly 6943 J2 9-10 connects VCC_PWRBD from baseboard to GPIO057 on the chip.
 * Select GPIO106 as PWROK output. JP19 2-3. Measure at JP71-3
 *
 * Emulate eSPI Host using QSPI
 * JP18 20-21 connect GPIO002 to SHD_nCS1
 * JP16 14-15 connect GPIO122 to PVT_IO1
 * JP16 11-12 connect GPIO123 to PVT_IO2
 * JP110 1-2 U10 OE connected to VTR3 (enabled)
 * JP116 1-2 U12 and U13 nOE connected to VTR3 (disabled)
 *
 * QSPI SHD pins are on VTR2 set to 1.8V fly-wired to eSPI pins.
 * NOTE: keep fly-wires short or use twisted pairs.
 *   1.8V               1.8V                     +3.3V
 * SHD_nCS1 J18-10 ->  ESPI_nCS J46-1  <-> U10 <-> ESPI_nRESET_R J52-19, JP114-1
 * SHD_CLK  J18-2  ->  ESPI_CLK J46-3  <-> U10 <-> ESPI_CLK_R    J52-13
 * SHD_IO0  J18-6  <-> ESPI_IO0 J46-5  <-> U10 <-> ESPI_IO0_R    J52-7
 * SHD_IO1  J18-7  <-> ESPI_IO0 J46-7  <-> U10 <-> ESPI_IO1_R    J52-5
 * SHD_IO2  J18-8  <-> ESPI_IO0 J46-9  <-> U10 <-> ESPI_IO2_R    J52-3
 * SHD_IO3  J18-9  <-> ESPI_IO0 J46-11 <-> U10 <-> ESPI_IO3_R    J52-1
 *
 * Emulated eSPI Host drives ESPI_nRESET to Target
 * NOTE: GPIO123/PVT_IO2 is on VTR1. We connect to +3.3V signal ESPI_nRESET_R
 * PVT_IO2  J18-14 -> ESPI_nRESET_R JP109-1 (no jumper)
 *
 * MEC5 eSPI target drives ESPI_nALERT to Host
 * ESPI_nALERT_R J52-23 -> PVT_IO1 J18-13
 *
 * ------------------------------------------------------------------------
 * Alternative: emulate eSPI using GP-SPI controller 0. Limitations:
 * GP-SPI controllers are full-duplex or dual. Not Quad.
 * GP-SPI controller pins are all on the VTR1 domain. We must connect differntly.
 * eSPI pins are connected to bi-direction voltage translator U10. The other
 * side of U10 are ESPI_xxx_R +3.3V signals connected to header J52
 * U10 requires jumper on JP110 1-2 connecting OE to VTR3
 *
 * Wires:
 * J34 1x6
 * pin 1 VTR1
 * pin 2 SPI0_CLK to J52-13 ESPI_CLK_R
 * pin 3 SPI0_SDO to J52-7  ESPI_IO0_R
 * pin 4 SPI0_SDI to J52-5  ESPI_IO1_R
 * pin 5 SPI0_nCS to J52-9  ESPI_nCS_R
 * pin 6 GND
 *
 * J52-19 ESPI_nRESET_R to JP70-11 GPIO005
 * J52-23 ESPI_nRESET_R to JP70-17 GPIO006
 *
 * Jumpers for GPIO005, GPIO006
 * JP24: 31-32, 46-47
 * JP27: 19-20, 28-29
 * JP29: 4-5, 1-2
 *
 * Jumpers for SPI0_xxx signals
 * JP15 3x6: 2-3, 5-6, 8-9, 11-12, 17-18
 * JP85 3x4: 1-2, 4-5, 7-8, 10-11
 *
 * ------------------------------------------------------------------------
 * GPIO175/CMP_VOUT1/PWM8_ALT on schematic, LED4 on silkscreen.
 * JP19 16-17 connects GPIO175 as CMP_VOUT1
 *
 * I2C00_SDA/SCL = GPIO003/004 selection
 * Install Jumpers on JP15 4-5, JP15 7-8, JP27 31-32, JP27 34-35
 * If pull-ups on the EVB are required:
 * Install Jumper JP70 19-20 7.5K pull-up to VTR1 for I2C00_SCL
 * Install Jumper JP70 21-22 7.5K pull-up to VTR1 for I2C00_SDA
 *
 * I2C devices on EXTERNAL_SDA/SCL bus
 *
 * U4 is PCA9555 I2C GPIO expander
 * JP52 1-2 use +3.3V_STBY
 * JP61 1-2, 3-4 connects I2C00_SCL and I2C00_SDA to EXTERNAL_SCLK/SDATA
 * JP55 selects I2C address
 * 1-2 = A0, 3-4 = A1, 5-6 = A2 all pulled-up by default. Install jumper to ground signals.
 * Installed jumper on JP53 1-2. I2C Address = 0x26
 *
 * U18 is LTC2489CDE I2C 4-channel delta-sigma ADC
 * NOTE: LTC2489 is powered by +5V.
 * Address select pins CA0, CA1 both pulled high. Install jumpers to ground signals.
 * Installed jumpers on JP121 1-2 and 3-4. I2C Address = 0x34
 * VRef=3V J51 1-2
 * Channel 0 connected to Vin=2.048V JP120 1-2, J51 3-4
 */

/ {
	aliases {
		spi0 = &qspi0;
		led0 = &led4;
	};

	leds {
		compatible = "gpio-leds";
		led4: led_0 {
			gpios = <MCHP_GPIO_DECODE_175 GPIO_ACTIVE_HIGH>;
		};
	};

	/* zephyr,user is a special case node for application & test use
	 * This node does not require a YAML binding file.
	 * espi-gpio pins
	 * index 0 = pin connected to ESPI_nRESET allowing app to control reset.
	 * index 1 = eSPI IO[1] GPIO used as eSPI ALERT. eSPI Target controller
	 * drives this pin low when it requires attention. Note: Target can drive
	 * eSPI ALERT pin when eSPI nCS is not asserted.
	 * index 2 = GPIO063 unused dedicated eSPI_nALERT pin. We use as GPIO to
	 * help measure code sequences.
	 * index 3 = GPIO030 used as GPIO output Host-to-Target VCC_PWRGD
	 * index 4 = GPIO031 used as GPIO input Target-nReady
	 * In application code use GPIO_DT_SPEC_GET_BY_IDX() macro.
	 */
	zephyr,user {
		espi-gpios = <MCHP_GPIO_DECODE_012 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_071 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_013 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_030 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_031 GPIO_ACTIVE_HIGH>;
	};
};
