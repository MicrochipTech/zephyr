/*
 * Copyright (c) 2024 Microchip Technology Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/gpio/gpio.h>
#include <zephyr/dt-bindings/gpio/microchip-xec-gpio.h>

/*
 * MEC5_ASSY6941
 * JP7 2-3 GPIO055 pulled-down via 10K to ground.
 * JP23 14-15 selects GPIO055 as SHD_nCS0
 * JP42 1-2 connects 1.8V
 * JP60 2-3 VTR2 is powered by 1.8V
 * NOTE: VTR3 is always 1.8V
 *
 * Boot-ROM GPIO055 as RSMRST#
 * GPIO Control register value = 0x0200
 * Output, push-pull, driver low, no internal pulls,
 * interrupt detection = level low, alternate out enabled.
 * ROM drives pin high(inactive) using alternate out (bit[16] of control register)
 * Control register = 0x10200
 *
 * GPIO175/CMP_VOUT1/PWM8_ALT on schematic, LED4 on silkscreen.
 *
 * I2C00_SDA/SCL = GPIO003/004
 * Install Jumper JP15 4-5 to route GPIO004 as I2C00_SCL/UART2_DCD
 * Install Jumper JP15 7-8 to route GPIO003 as I2C00_SDA/UART2_RI
 * Install Jumper JP27 34-35 to select I2C00_SDA
 * Install Jumper JP27 31-32 to select I2C00_SCL
 * Install Jumper JP70 19-20 7.5K pull-up to VTR1 for I2C00_SDA
 * Install Jumper JP70 21-22 7.5K pull-up to VTR1 for I2C00_SCL
 *
 * U4 is PCA9555 I2C GPIO expander
 * JP52 1-2 use +3.3V_STBY
 * JP61 1-2, 3-4 connect I2C00_SCL and I2C00_SDA to EXTERNAL_SCLK/SDATA
 * JP55 selects I2C address
 * 1-2 = A0, 3-4 = A1, 5-6 = A2 all pull-up by default. Install jumper to ground signals.
 * Installed jumper on JP55 1-2. I2C Address = 0x26
 *
 * U19 is LTC2489 I2C 4-channel delta-sigma ADC
 * Address select pins CA0, CA1 both pulled high. Install jumpers to ground signals.
 * Installed jumpers on JP124 1-2 and 3-4. I2C Address = 0x34
 *
 * Attached Fujitsu MB85RC256V I2C FRAM demo board to 6-pin header J10
 * AdaFruit I2C FRAM breakout board.
 * NOTE: removed demo board 1K pulls on SCL and SDA. Using EVB pulls on SCL/SDA.
 * This device allows testing of larger I2C messages and breaking up large transactions
 * into multiple message buffers.
 * FRAM board power -> J10-5 VTR1 (3.3V)
 * FRAM board GND   -> J10-6 GND
 * FRAM board SCL   -> J10-1 I2C00_SCL
 * FRAM board SDA   -> J10-3 I2C00_SDA
 * FRAM address pins A0, A1, A2 are internally pulled-down.
 * I2C Address = 1010_A2_A1_A0 = 0x50 (default)
 *
 * I2C Port 4 is on VTR1
 * JP20 3x4
 *  1-2 GPIO144 I2C04_SCL
 *  4-5 GPIO143 I2C04_SDA
 *
 * JP21 3x16
 *  13-14 GPIO144 I2C04_SCL
 *  25-26 GPIO143 I2C04_SDA
 *
 * pull-ups
 * JP71 25-26 connect 7.5K pull-up to VTR1
 * JP71 27-28 connect 7.5K pull-up to VTR1
 *
 * 1x6 header J17
 * 1 = I2C04_SCL
 * 2, 6 = GND
 * 3 = I2C04_SDA
 * 4 = NC
 * 5 = VTR1
 */

/ {
	chosen {
		zephyr,console = &uart1;
	};

	aliases {
		spi0 = &qspi0;
		led0 = &led4;
		i2c0 = &i2c_smb_0;
		i2c-0 = &i2c_smb_0;
		i2c-nl-0 = &i2c_smb_1;
	};

	leds {
		compatible = "gpio-leds";
		led4: led_0 {
			gpios = <MCHP_GPIO_DECODE_175 GPIO_ACTIVE_HIGH>;
		};
	};

	/* vci-pos is the bit position of the VCI_IN pin in the VCI registers
	 * vci-polarity use enum strings "Active_Low" or "Active_High"
	 * vci-latch-enable is a boolean. If present the VCI_IN at vci-pos latch is enable
	 * If not present the latching of the pin is disabled.
	 */
	hibernate_vci_pins {
		compatible = "microchip,ec-hibernate-vci";

		vci_input1: vci_input_1 {
			#gpio-cells=<2>;
			gpios = <MCHP_GPIO_DECODE_162 0>;
			vci-pos = <1>;
			vci-polarity = "Active_Low";
		};

		vci_input2: vci_input_2 {
			#gpio-cells=<2>;
			gpios = <MCHP_GPIO_DECODE_161 0>;
			vci-pos = <2>;
			vci-polarity = "Active_High";
			vci-latch-enable;
		};

		vci_input3: vci_input_3 {
			#gpio-cells=<2>;
			gpios = <MCHP_GPIO_DECODE_000 0>;
			vci-pos = <3>;
			vci-polarity = "Active_Low";
		};
	};
};

&dmac {
	status = "okay";
};

&i2c00_scl_gpio004 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

&i2c00_sda_gpio003 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

&uart1 {
	current-speed = <115200>;
	status = "okay";
	pinctrl-0 = <&uart1_tx_gpio170 &uart1_rx_gpio171>;
	pinctrl-names = "default";
};

&i2c_smb_0 {
	compatible = "microchip,mec5-i2c";
	status = "okay";
	port_sel = < 0 >;
	sda-gpios = < MCHP_GPIO_DECODE_003 0 >;
	scl-gpios = < MCHP_GPIO_DECODE_004 0 >;
	pinctrl-0 = < &i2c00_sda_gpio003 &i2c00_scl_gpio004 >;
	pinctrl-names = "default";

	pca9555_evb: pca9555@26 {
		/* Zephyr will load NXP PCA9555 driver after MEC5 I2C because it calls MEC5 I2C during init */
		compatible = "nxp,pca9555";
		reg = <0x26>;
		gpio-controller;
		#gpio-cells = <2>;
	};

	ltc2489_evb: ltc2489@34 {
		/* No Zephyr driver exists */
		reg = <0x34>;
		#io-channels-cells = <1>;
	};
};

&i2c_smb_1 {
	compatible = "microchip,mec5-i2c-nl";
	status = "okay";
	port_sel = < 4 >;
	sda-gpios = < MCHP_GPIO_DECODE_143 0 >;
	scl-gpios = < MCHP_GPIO_DECODE_144 0 >;
	pinctrl-0 = < &i2c04_sda_gpio143 &i2c04_scl_gpio144 >;
	pinctrl-names = "default";
	dmas = <&dmac 2 0x3>, <&dmac 3 0x2>;
	dma-names = "cm", "tm";
	target-addrs = <0x31>, <0x32>;

	/* External Fujitsu MB85RC256V 256KB (32K x 8) FRAM */
	mb85rc256v: mb85rc256v@50 {
		/* No Zephyr driver exists */
		reg = <0x50>;
	};
};
