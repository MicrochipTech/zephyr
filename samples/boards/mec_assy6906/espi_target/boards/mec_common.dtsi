/*
 * Copyright (c) 2024 Microchip Technology Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/gpio/gpio.h>
#include <zephyr/dt-bindings/gpio/microchip-xec-gpio.h>
#include <zephyr/dt-bindings/espi/mchp-mec5-espi.h>

/* Sample runs MEC_ASSY6906 board with MEC1723N-LJ or MEC1723N-SZ CPU card installed. */

/ {
	chosen {
		espi,os-acpi = &acpi_ec0;
		espi,host-cmd-acpi = &acpi_ec1;
		espi,host-mailbox = &mbox0;
		espi,host-shm = &emi0;
		espi,host-em8042 = &kbc0;
		espi,host-uart = &uart0;
		espi,host-io-capture = &p80bd0;
	};

	aliases {
		spi0 = &qspi0;
		led0 = &led4;
		i2c0 = &i2c_smb_0;
		i2c-0 = &i2c_smb_0;
	};

	leds {
		compatible = "gpio-leds";
		led4: led_0 {
			gpios = <MCHP_GPIO_DECODE_175 GPIO_ACTIVE_HIGH>;
		};
	};

	/* zephyr,user is a special case node for application & test use
	 * This node does not require a YAML binding file.
	 * espi-gpio pins
	 * index 0 = Target nREADY output to Host eSPI emulator
	 * index 1 = VCC_PWRGD_ALT drivent by external eSPI Emulated Host board
	 * In application code use GPIO_DT_SPEC_GET_BY_IDX() macro.
	 */
	zephyr,user {
		espi-gpios = <MCHP_GPIO_DECODE_031 GPIO_ACTIVE_HIGH>,
			     <MCHP_GPIO_DECODE_242 0>;
		pinctrl-0 = <&vcc_pwrgd_alt_gpio242 &pwrok_gpio106>;
		pinctrl-names = "default";
	};
};

&i2c00_scl_gpio004 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

&i2c00_sda_gpio003 {
	drive-open-drain;
	output-enable;
	output-high;
	drive-strength = "4x";
};

/* ---- eSPI and peripheral channel devices ---- */

&espi0 {
	status = "okay";
	pinctrl-0 = < &espi_reset_n_gpio061
		      &espi_clk_gpio065 &espi_cs_n_gpio066
		      &espi_io0_gpio070 &espi_io1_gpio071
		      &espi_io2_gpio072 &espi_io3_gpio073 >;
	pinctrl-names = "default";
	host-memmap-addr-high = <0x10>; /* bits[47:32] of Host address for memory mapped LDNs */
	sram-bar-addr-high = <0x20>; /* bits[47:32] of Host address for SRAM BARs */

	/* We create a node here for the UART we will expose to the Host
	 * Doing this makes sure this node is a child of espi0 required
	 * by espi0's driver.
	 */
	uart0_host: uart0_host {
		compatible = "microchip,mec5-host-uart";
		pinctrl-0 = < &uart0_tx_gpio104 &uart0_rx_gpio105 >;
		pinctrl-names = "default";
		hwdev = <&uart0>;
		host-infos = <&espi_uart0>;
		status = "okay";
	};
};

/* Map UART0 to Host I/O address space */
&espi_uart0 {
	host-address = <0x3f8>;
	sirqs = <4>;
	status = "okay";
};

/* Enable eSPI SRAM BAR0 to map a 256 byte region of EC SRAM to Host
 * address space with read-only access.
 * ISSUE: region-base, shouldn't this be the address of an application buffer?
 */
&espi_sram_bar0 {
	host-address-lsw = <0x20000000>;
	region-base = <0x118000>;
	region-size = "256B";
	access = "READ_ONLY";
	status = "okay";
};

/* Enable eSPI SRAM BAR1 to map a 256 byte region of EC SRAM to Host
 * address space with write-only access.
 */
&espi_sram_bar1 {
	host-address-lsw = <0x20001000>;
	region-base = <0x118100>;
	region-size = "256B";
	access = "WRITE_ONLY";
	status = "okay";
};

/* eSPI Host OS ACPI_EC device */
&acpi_ec0 {
	compatible = "microchip,mec5-acpi-ec-os";
	host-infos = <&espi_acpi_ec0>;
	status = "okay";
};

&espi_acpi_ec0 {
	host-address = <0x62>;
	sirqs = <5>;
	sirq-names = "ec_obf";
	status = "okay";
};

/* eSPI Host command ACPI_EC device */
&acpi_ec1 {
	compatible = "microchip,mec5-acpi-ec-hcmd";
	host-infos = <&espi_acpi_ec1>;
	status = "okay";
};

&espi_acpi_ec1 {
	host-address = <0x200>;
	sirqs = <0xff>;
	sirq-names = "ec_obf";
	status = "okay";
};

/* Use eSPI Host KBC driver and map KBC0 and KB Port92h to Host I/O space */
&kbc0 {
	compatible = "microchip,mec5-kbc";
	host-infos = <&espi_kbc0 &espi_kb_port92>;
	status = "okay";
};

&espi_kbc0 {
	host-address = <0x60>;
	sirqs = <1 12>;
	sirq-names = "kirq", "mirq";
	status = "okay";
};

&espi_kb_port92 {
	host-address = <0x92>;
	status = "okay";
};

/* Use eSPI Mailbox driver and map mailbox to Host I/O space */
&mbox0 {
	compatible="microchip,mec5-mailbox";
	host-infos = <&espi_mbox0>;
	status = "okay";
};

&espi_mbox0 {
	host-address = <0x300>;
	sirqs = <0xff 0xff>;
	status = "okay";
};

/* Map EMI0 to Host memory address space. */
&emi0 {
	compatible = "microchip,mec5-shm-emi";
	host-infos = <&espi_emi0>;
	status = "okay";
};

&espi_emi0 {
	host-address = <0x10000000>;
	host-mem-space;
};

/* Map EMI1 to Host memory address space */
&emi1 {
	compatible = "microchip,mec5-shm-emi";
	host-infos = <&espi_emi1>;
	status = "okay";
};

&espi_emi1 {
	host-address = <0x10001000>;
	host-mem-space;
};

/* eSPI Host I/O capture device. Map 4-byte Host I/O capture range and
 * optional 1-byte I/O alias.
 */
&p80bd0 {
	compatible = "microchip,mec5-bdp";
	host-infos = <&espi_bdp0 &espi_bdpa0>;
	status = "okay";
};

&espi_bdp0 {
	host-address = <0x80>;
};

&espi_bdpa0 {
	host-address = <0x90>;
	bdp-host-alias-byte-lane = <1>;
};

&i2c_smb_0 {
	status = "okay";
	port_sel = < 0 >;
	sda-gpios = < MCHP_GPIO_DECODE_003 0 >;
	scl-gpios = < MCHP_GPIO_DECODE_004 0 >;
	pinctrl-0 = < &i2c00_sda_gpio003 &i2c00_scl_gpio004 >;
	pinctrl-names = "default";

	pca9555_evb: pca9555@26 {
		compatible = "nxp,pca9555";
		reg = <0x26>;
		gpio-controller;
		#gpio-cells = <2>;
	};

	ltc2489_evb: ltc2489@34 {
		/* No Zephyr driver exists */
		reg = <0x34>;
		#io-channels-cells = <1>;
	};
};
